<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HBS Full Demo Application r012 - DEVELOPMENT VERSION</title>
    <script type="module">
        import * as PromptGenerator from './app/hbsPromptGenerator-r010-RESTORED.js';
        import { T2IPreviewer } from './app/t2i-previewer.js';
        
        window.PromptGenerator = PromptGenerator; // Make it available globally
        
        // Initialize T2I Previewer when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const previewerContainer = document.getElementById('t2i-previewer-container');
            if (previewerContainer) {
                window.t2iPreviewer = new T2IPreviewer();
                window.t2iPreviewer.init(previewerContainer);
            }
        });
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .hbs-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .group-button {
            color: white;
            border: none;
            padding: 15px 20px;
            width: 100%;
            text-align: left;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
        }

        .group-button:hover {
            background-color: #2980b9;
        }

        .group-button.completed {
            background-color: #2ecc71;
        }

        .group-button.inactive {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .group-content {
            height: 0;
            overflow: hidden;
            transition: height 0.3s ease-out;
        }

        .group-content.active {
            height: auto;
            transition: height 0.3s ease-in;
        }

        .parameter {
            border-bottom: 1px solid #eee;
            padding: 15px 20px;
            transition: all 0.3s;
        }

        .parameter h3 {
            margin-top: 0;
            color: #333;
        }

        .option {
            margin: 15px 0;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .option:hover {
            border-color: #3498db;
            background-color: #f8f9ff;
        }
        
        .option.selected {
            border-color: #3498db;
            background-color: #ebf5fb;
        }

        .options-container {
            margin-left: 20px;
        }

        .completed-section {
            padding: 10px 20px;
            background-color: #e8f4f8;
            border-top: 1px solid #d1e6f1;
        }

        .completed-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #d1e6f1;
        }

        .completed-item:last-child {
            border-bottom: none;
        }

        .next-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 15px;
            font-weight: bold;
        }

        .next-button:hover {
            background-color: #2980b9;
        }
        
        .progress-indicator {
            height: 5px;
            background-color: #e0e0e0;
            margin-top: -2px;
            position: relative;
        }
        
        .progress-bar {
            height: 100%;
            width: 0;
            transition: width 0.3s;
        }
        
        .chevron {
            transition: transform 0.3s;
        }
        
        .group-button.active .chevron {
            transform: rotate(180deg);
        }
        
        .hidden {
            display: none;
        }
        
        .option-label {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .option-description {
            margin-top: 12px;
            color: #666;
        }
        
        .description-label {
            font-weight: bold;
            color: #333;
            display: inline-block;
            width: 100px;
        }
        
        /* Fix: Target the actual content structure for "As Seen In" text using improved styling */
        .option-description div:nth-child(2) {
            font-weight: bold;
            /* Use a font stack that explicitly includes Arial Bold */
            font-family: "Arial Bold", "Arial Black", Arial, sans-serif;
            font-variant: normal;
        }
        
        /* Keep the label itself styled properly */
        .option-description div:nth-child(2) .description-label {
            color: #333;
        }

        .edit-button {
            background-color: #f39c12;
            color: white;
            border: none;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
        }

        .parameter-status {
            font-size: 12px;
            font-style: italic;
            color: #666;
            margin-bottom: 10px;
        }

        .parameter-description {
            margin-bottom: 15px;
            color: #333;
        }

        .modifiers-section {
            margin-top: 20px;
            border-top: 1px dashed #e0e0e0;
            padding-top: 15px;
        }

        .modifier {
            margin-bottom: 15px;
        }

        .modifier-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .modifier-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-left: 15px;
        }

        .modifier-option {
            padding: 5px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            cursor: pointer;
            background-color: #f9f9f9;
            transition: all 0.2s;
        }

        .modifier-option:hover {
            border-color: #3498db;
            background-color: #f0f7fc;
        }

        .modifier-option.selected {
            border-color: #3498db;
            background-color: #ebf5fb;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #666;
        }

        .character-preview {
            margin-top: 20px;
            padding: 20px;
            background-color: #f0f7fc;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .character-summary-container {
            flex: 1;
            min-width: 300px;
        }
        
        .character-formats-container {
            flex: 1;
            min-width: 300px;
        }
        
        .scrollable-summary {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #d1e6f1;
            border-radius: 4px;
            padding: 10px;
            background-color: white;
            resize: vertical; /* Allows vertical resizing only */
            min-height: 100px;
            margin-bottom: 15px;
        }
        
        /* Adjust the tab content for new layout */
        .tab-content {
            max-height: 350px; /* Increased height to balance with summary */
        }
        
        /* Improve the appearance of the character-preview header */
        .section-header {
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid #d1e6f1;
            padding-bottom: 10px;
            color: #2c3e50;
            font-weight: bold;
        }
        
        /* Make resize handle more visible */
        .scrollable-summary::-webkit-resizer {
            background-color: #d1e6f1;
            border: 2px solid #3498db;
        }

        /* Group-specific colors */
        #group-1 {
            background-color: #3498db; /* Original blue for Group 1 */
        }
        
        #group-1:hover {
            background-color: #2980b9; /* Darker blue for hover */
        }
        
        #group-2 {
            background-color: #9b59b6; /* Purple for Group 2 */
        }
        
        #group-2:hover {
            background-color: #8e44ad; /* Darker purple for hover */
        }
        
        #group-3 {
            background-color: #e67e22; /* Orange for Group 3 */
        }
        
        #group-3:hover {
            background-color: #d35400; /* Darker orange for hover */
        }
        
        #group-4 {
            background-color: #16a085; /* Teal for Group 4 */
        }
        
        #group-4:hover {
            background-color: #138873; /* Darker teal for hover */
        }
        
        /* Completed state colors */
        #group-1.completed {
            background-color: #2ecc71; /* Green for completed state - keeping original */
        }
        
        #group-2.completed {
            background-color: #27ae60; /* Darker green for Group 2 completed */
        }
        
        #group-3.completed {
            background-color: #2ecc71; /* Green for Group 3 completed */
        }
        
        #group-4.completed {
            background-color: #27ae60; /* Darker green for Group 4 completed */
        }
        
        /* Inactive state colors - keep consistent gray */
        .group-button.inactive {
            background-color: #95a5a6; /* Keep existing gray for inactive state */
            cursor: not-allowed;
        }
        
        /* Progress bar colors to match group headers */
        #progress-1 {
            background-color: #3498db;
        }
        
        #progress-2 {
            background-color: #9b59b6;
        }
        
        #progress-3 {
            background-color: #e67e22;
        }
        
        #progress-4 {
            background-color: #16a085;
        }
        
        .composed-prompt-text {
            font-family: 'Courier New', monospace;
            background-color: #fff;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-word;
            margin-bottom: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* Styles for prompt tabs */
        .prompt-tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        .tab-button {
            background-color: #f1f1f1;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            margin-right: 2px;
        }
        
        .tab-button:hover {
            background-color: #e0e0e0;
        }
        
        .tab-button.active {
            background-color: #3498db;
            color: white;
        }
        
        .tab-content {
            display: none;
            padding: 15px;
            border: 1px solid #ddd;
            border-top: none;
            margin-bottom: 15px;
            background-color: white;
            border-radius: 0 0 4px 4px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .tab-content pre {
            margin: 0;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        .copy-content-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        
        .copy-content-button:hover {
            background-color: #2980b9;
        }

        /* Add new styles for the format buttons container */
        .format-buttons-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            margin-bottom: 10px;
            align-items: flex-start; /* Align items at the top */
        }

        .format-buttons-container button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            height: 36px; /* Standardize button height */
            line-height: 20px; /* Ensure text is vertically centered */
            box-sizing: border-box; /* Include padding in height calculation */
            display: flex; /* Use flexbox for content alignment */
            align-items: center; /* Center text vertically */
            justify-content: center; /* Center text horizontally */
            margin: 0; /* Remove any default margins to ensure consistent alignment */
        }

        .format-buttons-container button:hover {
            background-color: #2980b9;
        }

        .format-buttons-container .export-button {
            background-color: #27ae60;
        }

        .format-buttons-container .export-button:hover {
            background-color: #219653;
        }

        .random-button-container {
            margin-top: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .random-button {
            background-color: #9b59b6; /* Purple color matching Group 2 */
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .random-button:hover {
            background-color: #8e44ad; /* Darker purple for hover state */
        }

        .random-button.active {
            background-color: #27ae60; /* Green when active (same as completed group) */
        }

        .random-speed {
            width: 150px;
            margin: 0 10px;
        }

        .format-buttons-container .save-button {
            background-color: #f39c12; /* Orange color */
        }

        .format-buttons-container .save-button:hover {
            background-color: #d35400;
        }

        .format-buttons-container .load-button {
            background-color: #9b59b6; /* Purple color */
        }

        .format-buttons-container .load-button:hover {
            background-color: #8e44ad;
        }

        .format-buttons-container .new-button {
            background-color: #16a085; /* Teal color */
        }

        .format-buttons-container .new-button:hover {
            background-color: #138873;
        }

        .character-name {
            font-size: 20px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px dashed #d1e6f1;
            text-align: center;
            display: none; /* Hidden by default until a name is set */
        }
        
        /* Add styling for keyboard shortcuts help */
        .keyboard-shortcuts {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
            text-align: right;
        }
        
        .keyboard-shortcuts kbd {
            background-color: #f1f1f1;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px 5px;
            font-family: monospace;
        }
        
        /* Add notification styling */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #27ae60;
            color: white;
            padding: 12px 20px;
            border-radius: 5px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s, transform 0.3s;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* Add these styles for the T2I Previewer error states */
        .t2i-error {
            padding: 15px;
            background-color: #fff0f0;
            border: 1px solid #ffcaca;
            border-radius: 4px;
            color: #e74c3c;
        }
        
        .t2i-error ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .t2i-error .t2i-prompt-used {
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .t2i-loading {
            padding: 20px;
            text-align: center;
            color: #777;
        }
        
        .t2i-no-prompt {
            padding: 20px;
            text-align: center;
            color: #777;
            font-style: italic;
        }
    </style>
</head>
<body>
    <h1>Human Build System - Full Demo r012</h1>
    <p>Create a character by selecting parameters across all four taxonomy groups. This is a full implementation using the complete HBS taxonomy.</p>
    
    <div class="character-preview">
        <!-- Left side: Character Summary - HIDDEN -->
        <div class="character-summary-container" style="display: none;">
            <h2 class="section-header">Character Summary</h2>
            <!-- Add character name display -->
            <div class="character-name" id="character-name-display"></div>
            <div class="scrollable-summary" id="character-summary">
                <p>No parameters selected yet. Begin by selecting options below.</p>
            </div>
        </div>
        
        <!-- Right side: Tab navigation for different formats - Now full width -->
        <div class="character-formats-container" style="flex: 1 1 100%; width: 100%;">
            <h2 class="section-header">Output Formats</h2>
            <div class="prompt-tabs">
                <button class="tab-button active" data-tab="description">Description</button>
                <button class="tab-button" data-tab="t2i-prompt">T2I Prompt</button>
                <button class="tab-button" data-tab="t2i-preview">T2I Previewer</button>
                <button class="tab-button" data-tab="markdown">Markdown</button>
                <button class="tab-button" data-tab="json">JSON</button>
            </div>
            
            <!-- Tab content containers -->
            <div class="tab-content active" id="description-tab">
                <!-- Description will be populated here -->
            </div>
            <div class="tab-content" id="t2i-prompt-tab">
                <!-- T2I prompt will be populated here -->
            </div>
            <div class="tab-content" id="t2i-preview-tab">
                <div id="t2i-previewer-container"></div>
            </div>
            <div class="tab-content" id="markdown-tab">
                <pre id="markdown-content"></pre>
            </div>
            <div class="tab-content" id="json-tab">
                <pre id="json-content"></pre>
            </div>
            
            <!-- Button group for all format-related operations -->
            <div class="format-buttons-container">
                <button class="copy-content-button">Copy Current Prompt</button>
                <button class="copy-button" onclick="copyCharacter()">Copy Character Summary</button>
                <button class="save-button" onclick="saveCharacter()">Save Character</button>
                <button class="load-button" onclick="loadCharacter()">Load Character</button>
                <button class="new-button" onclick="newCharacter()">New Character</button>
            </div>
            
            <!-- Add keyboard shortcuts help -->
            <div class="keyboard-shortcuts">
                Shortcuts: <kbd>Ctrl+S</kbd> Save | <kbd>Ctrl+O</kbd> Load | <kbd>Ctrl+N</kbd> New
            </div>
        </div>
        
        <!-- Bottom: Random generator only -->
        <div style="width: 100%;">
            <div class="random-button-container">
                <button id="random-button" class="random-button" onclick="toggleRandomGeneration()">Auto-Random</button>
                <div>
                    <label>Speed: </label>
                    <input type="range" id="random-speed" class="random-speed" min="100" max="2000" step="100" value="500">
                    <span id="speed-value">0.5s</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="hbs-container" id="main-container">
        <div class="loading">Loading taxonomy data...</div>
    </div>

    <!-- Add notification element -->
    <div class="notification" id="notification">Character saved successfully!</div>

    <script>
        // Global variables to store taxonomy data and character selections
        let taxonomyData = {};
        const selections = {};
        const completedParams = {};
        const modifierSelections = {};
        let paramGroups = {};
        let parameters = {};
        let groupStarts = {};
        let nextParam = {};
        let rules = { absoluteRules: [], suggestiveRules: [] }; // Store rules between parameters

        // Random character generation variables
        let isRandomGenerating = false;
        let randomTimer = null;
        let randomSpeed = 500; // ms
        let currentRandomGroup = 1;
        let currentParameterIndex = 0;

        // Explicitly define the essential functions in the global scope
        // This ensures they're available for onclick handlers
        
        // Select an option for a parameter
        window.selectOption = function(paramId, optionIndex, variantIndex) {
            // Get all options for this parameter
            const options = document.getElementById(`options-${paramId}`).querySelectorAll('.option');
            
            // Remove 'selected' class from all options
            for (let i = 0; i < options.length; i++) {
                options[i].classList.remove('selected');
            }
            
            // For Hair Color, we need to find the correct option by calculating its position
            const groupNum = paramGroups[paramId];
            const parameter = taxonomyData[groupNum].parameters.find(p => p.id === paramId);
            
            let selectedOptionElement;
            if (parameter.name === "Hair Color" && variantIndex !== undefined) {
                // Find the correct option by counting
                let optionCount = 0;
                for (let i = 0; i < optionIndex; i++) {
                    if (parameter.options[i].variants) {
                        optionCount += parameter.options[i].variants.length;
                    } else {
                        optionCount++;
                    }
                }
                selectedOptionElement = options[optionCount + variantIndex];
                // Store both main color and variant
                selections[paramId] = {
                    mainColorIndex: optionIndex,
                    variantIndex: variantIndex
                };
            } else {
                // Standard option selection
                selectedOptionElement = options[optionIndex];
                selections[paramId] = optionIndex;
            }
            
            // Add 'selected' class to the chosen option
            if (selectedOptionElement) {
                selectedOptionElement.classList.add('selected');
            }
            
            // Special handling when gender is selected
            if (paramId === 1) {
                // Clear any previously applied gender suggestions
                document.querySelectorAll('.option.suggested-gender').forEach(option => {
                    option.classList.remove('suggested-gender');
                    option.style.borderRight = '';
                    
                    const indicator = option.querySelector('.gender-match-indicator');
                    if (indicator) {
                        option.removeChild(indicator);
                    }
                });
                
                // Hide or show facial hair parameter based on gender
                const selectedGender = parameter.options[optionIndex].name.toLowerCase();
                handleFacialHairVisibility(selectedGender.includes('female'));
            }
            
            // Apply rules after selection
            clearRuleEffects(); // Clear existing rule effects
            applyRules(paramId, optionIndex, variantIndex);
            
            // Update character summary
            updateCharacterSummary();
        };

        // Add function to select modifiers - expose to global scope
        window.selectModifier = function(paramId, modifierName, optionIndex) {
            // Initialize if doesn't exist yet
            if (!modifierSelections[paramId]) {
                modifierSelections[paramId] = {};
            }
            
            const modifierElement = Array.from(document.getElementById(`options-${paramId}`).querySelectorAll('.modifier'))
                .find(mod => mod.querySelector('.modifier-name').textContent === modifierName);
            if (!modifierElement) return;
            
            // Get all modifier options
            const modOptions = modifierElement.querySelectorAll('.modifier-option');
            
            // Remove 'selected' class from all options
            for (let i = 0; i < modOptions.length; i++) {
                modOptions[i].classList.remove('selected');
            }
            
            // Add 'selected' class to the chosen option
            modOptions[optionIndex].classList.add('selected');
            
            // Store the selection
            modifierSelections[paramId][modifierName] = optionIndex;
            
            // Update character summary
            updateCharacterSummary();
        };

        // Edit a parameter that was already completed - expose to global scope
        window.editParameter = function(paramId) {
            const groupNum = paramGroups[paramId];
            
            // Hide all parameters in this group
            taxonomyData[groupNum].parameters.forEach(param => {
                document.getElementById(`parameter-${param.id}`).classList.add('hidden');
            });
            
            // Show the parameter to edit
            const paramElement = document.getElementById(`parameter-${paramId}`);
            paramElement.classList.remove('hidden');
            
            // Remove the disabled-parameter class if it exists when editing
            if (paramElement.classList.contains('disabled-parameter')) {
                paramElement.classList.remove('disabled-parameter');
                paramElement.style.opacity = '';
                
                // Also re-enable all options when editing a previously disabled parameter
                const options = paramElement.querySelectorAll('.option');
                options.forEach(option => {
                    option.classList.remove('disabled');
                    option.style.opacity = '';
                    option.style.cursor = 'pointer';
                    
                    // Restore click handlers
                    const paramObj = taxonomyData[groupNum].parameters.find(p => p.id === paramId);
                    if (paramObj && paramObj.name === "Hair Color") {
                        // Special handling for Hair Color with variants
                        // This is more complex and would need to restore variant handlers
                    } else {
                        // For standard parameters
                        const optionIndex = Array.from(option.parentNode.children).indexOf(option);
                        option.onclick = () => window.selectOption(paramId, optionIndex);
                    }
                });
                
                // Re-enable the next button
                const nextButton = paramElement.querySelector('.next-button');
                if (nextButton) {
                    nextButton.disabled = false;
                    nextButton.style.opacity = '';
                    nextButton.style.cursor = 'pointer';
                }
            }
            
            // Make sure group is expanded
            if (!document.getElementById(`content-${groupNum}`).classList.contains('active')) {
                toggleGroup(groupNum);
            }
            
            // Re-select the previously selected option
            if (selections[paramId] !== undefined) {
                if (typeof selections[paramId] === 'object') {
                    // For Hair Color with variants
                    window.selectOption(paramId, selections[paramId].mainColorIndex, selections[paramId].variantIndex);
                } else {
                    // For standard options
                    window.selectOption(paramId, selections[paramId]);
                }
            }
            
            // Re-select modifiers
            if (modifierSelections[paramId]) {
                Object.entries(modifierSelections[paramId]).forEach(([modifierName, optionIndex]) => {
                    const modifierContainer = document.getElementById(`options-${paramId}`);
                    const modifierSection = Array.from(modifierContainer.querySelectorAll('.modifier')).find(
                        el => el.querySelector('.modifier-name').textContent === modifierName
                    );
                    
                    if (modifierSection) {
                        const modOptions = modifierSection.querySelectorAll('.modifier-option');
                        if (modOptions.length > optionIndex) {
                            modOptions[optionIndex].classList.add('selected');
                        }
                    }
                });
            }
            
            // Apply all rules after re-editing - but ensure we can still edit this parameter
            setTimeout(() => {
                // We need to make sure rules don't re-disable the parameter we're editing
                applyAllRules();
                
                // Force this parameter to be editable even if rules would disable it
                paramElement.classList.remove('disabled-parameter');
                paramElement.style.opacity = '';
                
                // Also ensure options and next button remain enabled
                paramElement.querySelectorAll('.option').forEach(option => {
                    if (option.classList.contains('selected')) {
                        option.classList.remove('disabled');
                        option.style.opacity = '';
                        option.style.cursor = 'pointer';
                    }
                });
                
                const nextButton = paramElement.querySelector('.next-button');
                if (nextButton) {
                    nextButton.disabled = false;
                    nextButton.style.opacity = '';
                    nextButton.style.cursor = 'pointer';
                }
            }, 200);
        };

        // Expose completeParameter function to global scope since it's referenced elsewhere
        window.completeParameter = function(paramId) {
            // Check if an option is selected
            if (selections[paramId] === undefined) {
                alert('Please select an option first');
                return;
            }
            
            const groupNum = paramGroups[paramId];
            const parameter = taxonomyData[groupNum].parameters.find(p => p.id === paramId);
            
            let selectedOption, optionLabel, visual, seenIn;
            
            // Handle Hair Color with variants
            if (parameter.name === "Hair Color" && typeof selections[paramId] === 'object') {
                const mainOption = parameter.options[selections[paramId].mainColorIndex];
                const variant = mainOption.variants[selections[paramId].variantIndex];
                
                selectedOption = variant;
                optionLabel = `${mainOption.name} - ${variant.name}`;
                visual = variant.visual;
                seenIn = variant.as_seen_in;
            } else {
                // Standard option handling
                selectedOption = parameter.options[selections[paramId]];
                optionLabel = selectedOption.name;
                visual = selectedOption.visual;
                seenIn = selectedOption.asSeenIn;
            }
            
            // Store completion with modifiers
            completedParams[paramId] = {
                value: optionLabel,
                visual: visual,
                seenIn: seenIn,
                modifiers: modifierSelections[paramId] || {}
            };
            
            // Update completed section
            const completedSection = document.getElementById(`completed-${groupNum}`);
            
            // Clear any existing item for this parameter (in case it's being re-edited)
            const existingItem = document.getElementById(`completed-item-${paramId}`);
            if (existingItem) {
                existingItem.remove();
            }
            
            // Create completed item with edit button
            const completedItem = document.createElement('div');
            completedItem.id = `completed-item-${paramId}`;
            completedItem.className = 'completed-item';
            
            // Get modifier info for display
            let modifierText = '';
            if (modifierSelections[paramId]) {
                const modifierEntries = Object.entries(modifierSelections[paramId]);
                if (modifierEntries.length > 0) {
                    modifierText = ' (';
                    modifierEntries.forEach(([modName, modIndex], idx) => {
                        // Access the modifier by property name directly, not using .find()
                        if (parameter.modifiers && parameter.modifiers[modName]) {
                            const modOptions = parameter.modifiers[modName];
                            if (modOptions && modOptions[modIndex]) {
                                modifierText += `${modOptions[modIndex].name}${idx < modifierEntries.length - 1 ? ', ' : ''}`;
                            }
                        }
                    });
                    modifierText += ')';
                }
            }
            
            completedItem.innerHTML = `
                <div><strong>${paramId}. ${parameter.name}:</strong> ${optionLabel}${modifierText}</div>
                <div><button class="edit-button" onclick="editParameter(${paramId})">Edit</button></div>
            `;
            
            completedSection.appendChild(completedItem);
            completedSection.classList.remove('hidden');
            
            // Calculate group progress
            const groupParams = Object.keys(paramGroups).filter(key => paramGroups[key] === groupNum);
            const totalParamsInGroup = groupParams.length;
            const completedParamsInGroup = Object.keys(completedParams)
                .filter(key => paramGroups[key] === groupNum).length;
            
            const progress = (completedParamsInGroup / totalParamsInGroup) * 100;
            document.getElementById(`progress-${groupNum}`).style.width = `${progress}%`;
            
            // Check if this was the last parameter in the group
            const next = nextParam[paramId];
            
            if (next && document.getElementById(`parameter-${next}`)) {
                // Hide the current parameter
                document.getElementById(`parameter-${paramId}`).classList.add('hidden');
                
                // Check if the next parameter is Facial Hair and we need to auto-complete it for females
                const nextParamElement = document.getElementById(`parameter-${next}`);
                if (nextParamElement && nextParamElement.classList.contains('gender-hidden')) {
                    // This is the Facial Hair parameter and it's hidden for females
                    console.log("Auto-completing facial hair parameter for female character");
                    
                    // Auto-complete the facial hair parameter
                    completedParams[next] = {
                        value: "None (Female character)",
                        visual: "Not applicable for female characters",
                        seenIn: "",
                        modifiers: {}
                    };
                    
                    // Update completed section for facial hair
                    const facialHairParam = taxonomyData[groupNum].parameters.find(p => p.id === next);
                    if (facialHairParam) {
                        const facialHairItem = document.createElement('div');
                        facialHairItem.id = `completed-item-${next}`;
                        facialHairItem.className = 'completed-item';
                        facialHairItem.innerHTML = `
                            <div><strong>${next}. ${facialHairParam.name}:</strong> None (Female character)</div>
                            <div><button class="edit-button" onclick="editParameter(${next})">Edit</button></div>
                        `;
                        completedSection.appendChild(facialHairItem);
                    }
                    
                    // Skip to the parameter after facial hair in the group (after facial hair)
                    const afterFacialHair = nextParam[next];
                    if (afterFacialHair && document.getElementById(`parameter-${afterFacialHair}`)) {
                        // Show the parameter after facial hair
                        document.getElementById(`parameter-${afterFacialHair}`).classList.remove('hidden');
                    } else {
                        // This was the last parameter in the group, complete group 3 and move to group 4
                        handleGroupCompletion(groupNum); // Complete the group and move to Group 4
                    }
                } else {
                    // Standard case - show the next parameter
                    nextParamElement.classList.remove('hidden');
                }
            } else {
                // This was the last parameter in the group
                document.getElementById(`parameter-${paramId}`).classList.add('hidden');
                // Complete the group and move to the next one
                handleGroupCompletion(groupNum);
            }
            
            // Apply all rules after completion, but don't disable parameters in completed groups
            setTimeout(() => {
                applyAllRulesWithCompletedGroups();
            }, 500);
            
            // Update character summary
            updateCharacterSummary();
        };
        
        // Make sure to remove any duplicate function definitions later in the code

        // Create UI element for a parameter
        function createParameterElement(param, visible = false) {
            const paramElement = document.createElement('div');
            paramElement.id = `parameter-${param.id}`;
            paramElement.className = `parameter ${visible ? '' : 'hidden'}`;
            
            // Add parameter header and description
            paramElement.innerHTML = `
                <h3>${param.id}. ${param.name}</h3>
                <div class="parameter-status">${param.status}</div>
                <div class="parameter-description">${param.description}</div>
            `;
            
            // Create options container
            const optionsContainer = document.createElement('div');
            optionsContainer.id = `options-${param.id}`;
            optionsContainer.className = 'options-container';
            
            // Add options
            param.options.forEach((option, index) => {
                // Special handling for Hair Color which has variants structure
                if (param.name === "Hair Color" && option.variants) {
                    // For each variant in the Hair Color option, create a separate option element
                    option.variants.forEach((variant, variantIndex) => {
                        const variantOptionElement = document.createElement('div');
                        variantOptionElement.className = 'option';
                        // When clicked, this needs to store both the parent option and the variant
                        variantOptionElement.onclick = () => window.selectOption(param.id, index, variantIndex);
                        
                        variantOptionElement.innerHTML = `
                            <div class="option-label">${option.name} - ${variant.name}</div>
                            <div class="option-description">
                                <div><span class="description-label">Visual:</span> ${variant.visual}</div>
                                <div><span class="description-label">As Seen In:</span> ${variant.as_seen_in}</div>
                            </div>
                        `;
                        
                        optionsContainer.appendChild(variantOptionElement);
                    });
                } else {
                    // Standard options for other parameters
                    const optionElement = document.createElement('div');
                    optionElement.className = 'option';
                    optionElement.onclick = () => window.selectOption(param.id, index);
                    
                    // For all other parameters with standard structure
                    const visual = option.visual || option.description || option.Visual || option.Description || "";
                    const asSeenIn = option.asSeenIn || option.as_seen_in || option.AsSeenIn || option["As Seen In"] || "";
                    
                    optionElement.innerHTML = `
                        <div class="option-label">${option.name || "Unnamed Option"}</div>
                        <div class="option-description">
                            <div><span class="description-label">Visual:</span> ${visual}</div>
                            <div><span class="description-label">As Seen In:</span> ${asSeenIn}</div>
                        </div>
                    `;
                    
                    optionsContainer.appendChild(optionElement);
                }
            });
            
            // Add modifiers if present
            if (param.modifiers) {
                const modifiersSection = document.createElement('div');
                modifiersSection.className = 'modifiers-section';
                modifiersSection.innerHTML = '<h4>Modifiers</h4>';
                
                // Handle object-style modifiers (as in your JSON files)
                if (!Array.isArray(param.modifiers)) {
                    Object.entries(param.modifiers).forEach(([modName, modOptions]) => {
                        const modifierElement = document.createElement('div');
                        modifierElement.className = 'modifier';
                        
                        // Add modifier name
                        const modifierName = document.createElement('div');
                        modifierName.className = 'modifier-name';
                        modifierName.textContent = modName;
                        modifierElement.appendChild(modifierName);
                        
                        // Add modifier options
                        const modifierOptions = document.createElement('div');
                        modifierOptions.className = 'modifier-options';
                        
                        modOptions.forEach((option, optIndex) => {
                            const modOptionElement = document.createElement('div');
                            modOptionElement.className = 'modifier-option';
                            modOptionElement.textContent = option.name;
                            modOptionElement.onclick = () => window.selectModifier(param.id, modName, optIndex);
                            modifierOptions.appendChild(modOptionElement);
                        });
                        
                        modifierElement.appendChild(modifierOptions);
                        modifiersSection.appendChild(modifierElement);
                    });
                } else {
                    // Original code for array-style modifiers
                    param.modifiers.forEach(modifier => {
                        const modifierElement = document.createElement('div');
                        modifierElement.className = 'modifier';
                        
                        // Add modifier name
                        const modifierName = document.createElement('div');
                        modifierName.className = 'modifier-name';
                        modifierName.textContent = modifier.name;
                        modifierElement.appendChild(modifierName);
                        
                        // Add modifier options
                        const modifierOptions = document.createElement('div');
                        modifierOptions.className = 'modifier-options';
                        
                        modifier.options.forEach((option, optIndex) => {
                            const modOptionElement = document.createElement('div');
                            modOptionElement.className = 'modifier-option';
                            modOptionElement.textContent = option.name;
                            modOptionElement.onclick = () => window.selectModifier(param.id, modifier.name, optIndex);
                            modifierOptions.appendChild(modOptionElement);
                        });
                        
                        modifierElement.appendChild(modifierOptions);
                        modifiersSection.appendChild(modifierElement);
                    });
                }
                
                optionsContainer.appendChild(modifiersSection);
            }
            
            // Add next button
            const nextButton = document.createElement('button');
            nextButton.className = 'next-button';
            nextButton.textContent = 'Next';
            nextButton.onclick = () => window.completeParameter(param.id);
            optionsContainer.appendChild(nextButton);
            
            paramElement.appendChild(optionsContainer);
            return paramElement;
        }

        // Load taxonomy data and rules from external files
        async function loadTaxonomyData() {
            try {
                console.log("Attempting to load taxonomy data files");
                
                // Initialize taxonomyData as an object to hold all group data
                taxonomyData = {};
                
                // Load Group 1 taxonomy
                try {
                    const g1Response = await fetch('./data/hbs-taxonomy-g1-r010.json');
                    taxonomyData[1] = await g1Response.json();
                    console.log("Successfully loaded Group 1 taxonomy");
                } catch (g1Error) {
                    console.error("Failed to load Group 1 taxonomy:", g1Error);
                    // Try absolute path as fallback
                    try {
                        const g1Response = await fetch('/data/hbs-taxonomy-g1-r010.json');
                        taxonomyData[1] = await g1Response.json();
                    } catch (error) {
                        console.error("Failed to load Group 1 with absolute path:", error);
                    }
                }
                
                // Load Group 3 taxonomy
                try {
                    const g3Response = await fetch('./data/hbs-taxonomy-g3-r010.json');
                    taxonomyData[3] = await g3Response.json();
                    console.log("Successfully loaded Group 3 taxonomy");
                } catch (g3Error) {
                    console.error("Failed to load Group 3 taxonomy:", g3Error);
                    // Try absolute path as fallback
                    try {
                        const g3Response = await fetch('/data/hbs-taxonomy-g3-r010.json');
                        taxonomyData[3] = await g3Response.json();
                    } catch (error) {
                        console.error("Failed to load Group 3 with absolute path:", error);
                    }
                }
                
                // Load Group 4 taxonomy
                try {
                    const g4Response = await fetch('./data/hbs-taxonomy-g4-r010.json');
                    taxonomyData[4] = await g4Response.json();
                    console.log("Successfully loaded Group 4 taxonomy");
                } catch (g4Error) {
                    console.error("Failed to load Group 4 taxonomy:", g4Error);
                    // Try absolute path as fallback
                    try {
                        const g4Response = await fetch('/data/hbs-taxonomy-g4-r010.json');
                        taxonomyData[4] = await g4Response.json();
                    } catch (error) {
                        console.error("Failed to load Group 4 with absolute path:", error);
                    }
                }
                
                // Load rules
                try {
                    const rulesResponse = await fetch('./data/hbs-rules-r010.json');
                    rules = await rulesResponse.json();
                    console.log("Successfully loaded rules");
                } catch (rulesError) {
                    console.error("Failed to load rules:", rulesError);
                    // Try absolute path as fallback
                    try {
                        const rulesResponse = await fetch('/data/hbs-rules-r010.json');
                        rules = await rulesResponse.json();
                    } catch (error) {
                        console.error("Failed to load rules with absolute path:", error);
                    }
                }
                
                // Check if we successfully loaded the required taxonomy data
                if (!taxonomyData[1] || !taxonomyData[3] || !taxonomyData[4]) {
                    throw new Error("Failed to load all required taxonomy groups");
                }
                
                // Initialize UI once data is loaded
                initializeUI();
            } catch (error) {
                console.error('Error loading taxonomy data:', error);
                document.getElementById('main-container').innerHTML = `
                    <div class="error">
                        <h3>Error Loading Data</h3>
                        <p>Could not load taxonomy data. Please check the console for detailed errors.</p>
                        <p>Attempted to load data files with the following names:</p>
                        <ul>
                            <li>hbs-taxonomy-g1-r010.json</li>
                            <li>hbs-taxonomy-g3-r010.json</li>
                            <li>hbs-taxonomy-g4-r010.json</li>
                            <li>hbs-rules-r010.json</li>
                        </ul>
                        <p>Error details: ${error.message}</p>
                    </div>
                `;
            }
        }

        // Add the missing initializeUI function that's called in loadTaxonomyData
        function initializeUI() {
            const mainContainer = document.getElementById('main-container');
            mainContainer.innerHTML = ''; // Clear loading message
            
            // Create group containers
            Object.keys(taxonomyData).forEach((groupNum, index) => {
                const group = taxonomyData[groupNum];
                
                // Store parameter-to-group mapping
                group.parameters.forEach(param => {
                    paramGroups[param.id] = parseInt(groupNum);
                    parameters[param.id] = param;
                });
                
                // Set up chain of parameters for navigation
                for (let i = 0; i < group.parameters.length - 1; i++) {
                    nextParam[group.parameters[i].id] = group.parameters[i + 1].id;
                }
                
                // Create group button
                const groupButton = document.createElement('button');
                groupButton.id = `group-${groupNum}`;
                groupButton.className = `group-button ${index === 0 ? '' : 'inactive'}`;
                groupButton.innerHTML = `
                    ${group.name} <span class="chevron">▼</span>
                `;
                groupButton.onclick = () => toggleGroup(groupNum);
                
                // Create progress indicator
                const progressIndicator = document.createElement('div');
                progressIndicator.className = 'progress-indicator';
                progressIndicator.innerHTML = `<div id="progress-${groupNum}" class="progress-bar"></div>`;
                
                // Create group content container
                const groupContent = document.createElement('div');
                groupContent.id = `content-${groupNum}`;
                groupContent.className = `group-content ${index === 0 ? 'active' : ''}`;
                if (index === 0) {
                    // Set initial height for first group
                    setTimeout(() => {
                        groupContent.style.height = groupContent.scrollHeight + 'px';
                    }, 0);
                }
                
                // Create completed parameters section
                const completedSection = document.createElement('div');
                completedSection.id = `completed-${groupNum}`;
                completedSection.className = 'completed-section hidden';
                groupContent.appendChild(completedSection);
                
                // Create parameter elements and add to group content
                group.parameters.forEach((param, paramIndex) => {
                    // First parameter of first group is visible by default
                    const isVisible = index === 0 && paramIndex === 0;
                    const paramElement = createParameterElement(param, isVisible);
                    groupContent.appendChild(paramElement);
                    
                    // Store first parameter of each group
                    if (paramIndex === 0) {
                        groupStarts[groupNum] = param.id;
                    }
                });
                
                // Add elements to main container
                mainContainer.appendChild(groupButton);
                mainContainer.appendChild(progressIndicator);
                mainContainer.appendChild(groupContent);
            });
            
            // Set up event handlers for UI elements
            setupEventHandlers();
        }

        // Helper function to set up additional event handlers
        function setupEventHandlers() {
            // Tab navigation
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    
                    // Remove active class from all tabs and contents
                    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    
                    // Add active class to clicked tab and its content
                    this.classList.add('active');
                    document.getElementById(`${tabId}-tab`).classList.add('active');
                });
            });
            
            // Copy button
            document.querySelector('.copy-content-button')?.addEventListener('click', function() {
                const activeTab = document.querySelector('.tab-content.active');
                let textToCopy = '';
                
                if (activeTab) {
                    if (activeTab.id === 'description-tab') {
                        textToCopy = activeTab.textContent;
                    } else if (activeTab.id === 't2i-prompt-tab') {
                        textToCopy = activeTab.querySelector('.composed-prompt-text')?.textContent || '';
                    } else if (activeTab.id === 'markdown-tab' || activeTab.id === 'json-tab') {
                        textToCopy = activeTab.querySelector('pre')?.textContent || '';
                    }
                }
                
                if (textToCopy) {
                    navigator.clipboard.writeText(textToCopy)
                        .then(() => showNotification('Copied to clipboard!'))
                        .catch(err => console.error('Error copying text:', err));
                }
            });
            
            // Speed slider
            document.getElementById('random-speed')?.addEventListener('input', function() {
                randomSpeed = parseInt(this.value);
                document.getElementById('speed-value').textContent = (randomSpeed / 1000).toFixed(1) + 's';
            });
        }

        // Fix 1: Add missing handleFacialHairVisibility function
        function handleFacialHairVisibility(isFemale) {
            const facialHairParam = document.querySelector('.parameter[id^="parameter-"][id$="3"]'); // Find facial hair param (typically param 3)
            if (facialHairParam) {
                if (isFemale) {
                    facialHairParam.classList.add('gender-hidden');
                } else {
                    facialHairParam.classList.remove('gender-hidden');
                }
            }
        }
        
        // Fix 2: Add missing clearRuleEffects function
        function clearRuleEffects() {
            // Remove any rule-related styling or classes from all parameters
            document.querySelectorAll('.disabled-by-rule').forEach(elem => {
                elem.classList.remove('disabled-by-rule');
            });
            document.querySelectorAll('.suggested-by-rule').forEach(elem => {
                elem.classList.remove('suggested-by-rule');
            });
        }
        
        // Fix 3: Add missing applyRules function
        function applyRules(paramId, optionIndex, variantIndex) {
            if (!rules || (!rules.absoluteRules && !rules.suggestiveRules)) return;
            
            // Apply absolute rules that would disable options
            if (rules.absoluteRules) {
                for (const rule of rules.absoluteRules) {
                    // Logic to apply absolute rules based on current selections
                    // Implementation depends on rule structure
                }
            }
            
            // Apply suggestive rules
            if (rules.suggestiveRules) {
                for (const rule of rules.suggestiveRules) {
                    // Logic to apply suggestive rules
                }
            }
        }
        
        // Fix 4: Add missing handleGroupCompletion function
        function handleGroupCompletion(groupNum) {
            // Mark group as completed
            document.getElementById(`group-${groupNum}`).classList.add('completed');
            
            // Progress bar should be at 100%
            document.getElementById(`progress-${groupNum}`).style.width = "100%";
            
            // Check if there's a next group to activate
            const nextGroup = groupNum + 1;
            if (document.getElementById(`group-${nextGroup}`)) {
                // Activate next group
                document.getElementById(`group-${nextGroup}`).classList.remove('inactive');
                
                // Open the next group automatically
                if (!document.getElementById(`content-${nextGroup}`).classList.contains('active')) {
                    toggleGroup(nextGroup);
                }
                
                // Show the first parameter in the next group
                const firstParamInNextGroup = taxonomyData[nextGroup].parameters[0];
                if (firstParamInNextGroup) {
                    document.getElementById(`parameter-${firstParamInNextGroup.id}`).classList.remove('hidden');
                }
            }
        }
        
        // Fix 5: Add missing applyAllRules and applyAllRulesWithCompletedGroups functions
        function applyAllRules() {
            // Re-apply all rules based on current selections
            // This is called after editing a parameter
            Object.entries(selections).forEach(([paramId, optionIndex]) => {
                if (typeof optionIndex === 'object' && optionIndex.mainColorIndex !== undefined) {
                    // For Hair Color with variants
                    applyRules(parseInt(paramId), optionIndex.mainColorIndex, optionIndex.variantIndex);
                } else {
                    // For standard options
                    applyRules(parseInt(paramId), optionIndex);
                }
            });
        }
        
        function applyAllRulesWithCompletedGroups() {
            // Apply rules but respect completed groups
            applyAllRules();
            
            // Ensure completed groups remain active and their parameters aren't disabled
            Object.keys(taxonomyData).forEach(groupNum => {
                const isCompleted = document.getElementById(`group-${groupNum}`).classList.contains('completed');
                if (isCompleted) {
                    // Re-enable all parameters in completed groups if they were disabled by rules
                    taxonomyData[groupNum].parameters.forEach(param => {
                        const paramElement = document.getElementById(`parameter-${param.id}`);
                        if (paramElement) {
                            paramElement.classList.remove('disabled-parameter');
                            paramElement.style.opacity = '';
                        }
                    });
                }
            });
        }
        
        // Fix 6: Add missing updateCharacterSummary function
        function updateCharacterSummary() {
            const summaryContainer = document.getElementById('character-summary');
            if (!summaryContainer) return;
            
            // If no selections have been made yet, show default message
            if (Object.keys(completedParams).length === 0) {
                summaryContainer.innerHTML = '<p>No parameters selected yet. Begin by selecting options below.</p>';
                return;
            }
            
            // Generate summary HTML
            let summaryHTML = '';
            
            // Loop through groups in order
            Object.keys(taxonomyData).sort().forEach(groupNum => {
                const group = taxonomyData[groupNum];
                let hasCompletedParams = false;
                
                let groupHTML = `<div class="summary-group"><h3>${group.name}</h3><ul>`;
                
                // Loop through parameters in this group
                group.parameters.forEach(param => {
                    if (completedParams[param.id]) {
                        hasCompletedParams = true;
                        const completion = completedParams[param.id];
                        
                        // Add the parameter and its selected value
                        groupHTML += `<li><strong>${param.name}:</strong> ${completion.value}`;
                        
                        // Add modifiers if present
                        if (completion.modifiers && Object.keys(completion.modifiers).length > 0) {
                            groupHTML += ' (';
                            let modifierTexts = [];
                            
                            Object.entries(completion.modifiers).forEach(([modName, modIndex]) => {
                                if (param.modifiers && param.modifiers[modName]) {
                                    const modOption = param.modifiers[modName][modIndex];
                                    if (modOption) {
                                        modifierTexts.push(modOption.name);
                                    }
                                }
                            });
                            
                            groupHTML += modifierTexts.join(', ');
                            groupHTML += ')';
                        }
                        
                        groupHTML += '</li>';
                    }
                });
                
                groupHTML += '</ul></div>';
                
                // Add group HTML to summary if it has any completed parameters
                if (hasCompletedParams) {
                    summaryHTML += groupHTML;
                }
            });
            
            // Update the summary container
            summaryContainer.innerHTML = summaryHTML;
            
            // Also update generated outputs in tabs
            updateOutputFormats();
        }
        
        // Fix 7: Add missing updateOutputFormats function
        function updateOutputFormats() {
            // Generate different output formats based on selections
            
            // Description tab
            const descriptionTab = document.getElementById('description-tab');
            if (descriptionTab) {
                descriptionTab.innerHTML = generateDescriptionHTML();
            }
            
            // T2I prompt tab
            const t2iPromptTab = document.getElementById('t2i-prompt-tab');
            if (t2iPromptTab) {
                const promptText = PromptGenerator.generateT2IPrompt(completedParams, taxonomyData);
                t2iPromptTab.innerHTML = `<div class="composed-prompt-text">${promptText}</div>`;
            }
            
            // Markdown tab
            const markdownContent = document.getElementById('markdown-content');
            if (markdownContent) {
                markdownContent.textContent = generateMarkdown();
            }
            
            // JSON tab
            const jsonContent = document.getElementById('json-content');
            if (jsonContent) {
                jsonContent.textContent = JSON.stringify(
                    {
                        character: completedParams,
                        metadata: {
                            version: "HBS r012",
                            created: new Date().toISOString()
                        }
                    }, 
                    null, 2
                );
            }
            
            // Update the previewer if it exists
            if (window.t2iPreviewer) {
                const promptText = PromptGenerator.generateT2IPrompt(completedParams, taxonomyData);
                window.t2iPreviewer.updatePrompt(promptText);
            }
        }
        
        // Fix 8: Add toggleGroup function that's referenced elsewhere
        function toggleGroup(groupNum) {
            const button = document.getElementById(`group-${groupNum}`);
            const content = document.getElementById(`content-${groupNum}`);
            
            if (!button || !content) return;
            
            // If group is inactive, don't toggle
            if (button.classList.contains('inactive')) return;
            
            // Toggle active class for styling
            button.classList.toggle('active');
            content.classList.toggle('active');
            
            // Handle height transition for smooth animation
            if (content.classList.contains('active')) {
                // Get content height and set it for transition
                content.style.height = content.scrollHeight + 'px';
            } else {
                content.style.height = '0';
            }
        }
        
        // Fix 9: Add missing copy, save, load functions
        function copyCharacter() {
            const summaryText = document.getElementById('character-summary').innerText;
            navigator.clipboard.writeText(summaryText)
                .then(() => showNotification('Character summary copied to clipboard!'))
                .catch(err => console.error('Error copying text:', err));
        }
        
        function saveCharacter() {
            const characterData = {
                selections,
                completedParams,
                modifierSelections
            };
            
            // Convert to string and save to localStorage
            localStorage.setItem('hbsCharacter', JSON.stringify(characterData));
            showNotification('Character saved successfully!');
        }
        
        function loadCharacter() {
            const savedData = localStorage.getItem('hbsCharacter');
            if (!savedData) {
                showNotification('No saved character found!', 'error');
                return;
            }
            
            try {
                const characterData = JSON.parse(savedData);
                
                // Clear current selections
                Object.keys(selections).forEach(key => delete selections[key]);
                Object.keys(completedParams).forEach(key => delete completedParams[key]);
                Object.keys(modifierSelections).forEach(key => delete modifierSelections[key]);
                
                // Load saved data
                Object.assign(selections, characterData.selections);
                Object.assign(completedParams, characterData.completedParams);
                Object.assign(modifierSelections, characterData.modifierSelections);
                
                // Rebuild UI based on loaded data
                rebuildUIFromSavedData();
                
                showNotification('Character loaded successfully!');
            } catch (error) {
                console.error('Error loading character:', error);
                showNotification('Error loading character!', 'error');
            }
        }
        
        function newCharacter() {
            if (confirm('Start a new character? This will clear all current selections.')) {
                // Clear all selections
                Object.keys(selections).forEach(key => delete selections[key]);
                Object.keys(completedParams).forEach(key => delete completedParams[key]);
                Object.keys(modifierSelections).forEach(key => delete modifierSelections[key]);
                
                // Reset UI
                resetUI();
                
                showNotification('Started a new character!');
            }
        }
        
        // Fix 10: Add missing utility functions
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            // Hide notification after 3 seconds
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        function generateDescriptionHTML() {
            // Generate human-readable description
            let html = '<div class="character-description">';
            
            if (Object.keys(completedParams).length === 0) {
                html += '<p>No parameters selected yet.</p>';
                return html + '</div>';
            }
            
            // Add paragraph descriptions based on selections
            // This would be custom implementation depending on your needs
            
            return html + '</div>';
        }
        
        function generateMarkdown() {
            // Generate markdown representation of character
            let md = '# Character Description\n\n';
            
            // Group parameters by their group
            const paramsByGroup = {};
            
            Object.keys(completedParams).forEach(paramId => {
                const groupNum = paramGroups[paramId];
                if (!paramsByGroup[groupNum]) {
                    paramsByGroup[groupNum] = [];
                }
                paramsByGroup[groupNum].push(parseInt(paramId));
            });
            
            // Generate markdown by group
            Object.keys(paramsByGroup).sort().forEach(groupNum => {
                const group = taxonomyData[groupNum];
                md += `## ${group.name}\n\n`;
                
                // Sort parameters by ID within each group
                paramsByGroup[groupNum].sort().forEach(paramId => {
                    const param = taxonomyData[groupNum].parameters.find(p => p.id === paramId);
                    const completion = completedParams[paramId];
                    
                    md += `### ${param.name}\n\n`;
                    md += `- **Selected Option:** ${completion.value}\n`;
                    
                    if (completion.visual) {
                        md += `- **Visual:** ${completion.visual}\n`;
                    }
                    
                    if (completion.seenIn) {
                        md += `- **As Seen In:** ${completion.seenIn}\n`;
                    }
                    
                    // Add modifiers if present
                    if (completion.modifiers && Object.keys(completion.modifiers).length > 0) {
                        md += `- **Modifiers:**\n`;
                        
                        Object.entries(completion.modifiers).forEach(([modName, modIndex]) => {
                            if (param.modifiers && param.modifiers[modName]) {
                                const modOption = param.modifiers[modName][modIndex];
                                if (modOption) {
                                    md += `  - ${modName}: ${modOption.name}\n`;
                                }
                            }
                        });
                    }
                    
                    md += '\n';
                });
            });
            
            return md;
        }
        
        function toggleRandomGeneration() {
            isRandomGenerating = !isRandomGenerating;
            const randomButton = document.getElementById('random-button');
            
            if (isRandomGenerating) {
                randomButton.classList.add('active');
                randomButton.textContent = 'Stop Random';
                startRandomGeneration();
            } else {
                randomButton.classList.remove('active');
                randomButton.textContent = 'Auto-Random';
                clearTimeout(randomTimer);
            }
        }
        
        // Fix 11: Add missing random generation functions
        function startRandomGeneration() {
            randomSpeed = parseInt(document.getElementById('random-speed').value);
            document.getElementById('speed-value').textContent = (randomSpeed / 1000).toFixed(1) + 's';
            
            randomTimer = setTimeout(makeRandomSelection, randomSpeed);
        }
        
        function makeRandomSelection() {
            // Find which parameters are visible and not yet completed
            const visibleParams = Array.from(document.querySelectorAll('.parameter:not(.hidden)'));
            
            if (visibleParams.length > 0) {
                // Select a random parameter from visible ones
                const paramElement = visibleParams[0]; // Just take the first visible one for simplicity
                const paramId = parseInt(paramElement.id.replace('parameter-', ''));
                
                // Get all options for this parameter
                const options = Array.from(paramElement.querySelectorAll('.option:not(.disabled)'));
                
                if (options.length > 0) {
                    // Select a random option
                    const randomIndex = Math.floor(Math.random() * options.length);
                    const option = options[randomIndex];
                    
                    // Determine the option index within its parent
                    const optionIndex = Array.from(option.parentNode.children)
                        .filter(el => el.classList.contains('option'))
                        .indexOf(option);
                    
                    // Select this option
                    const groupNum = paramGroups[paramId];
                    const parameter = taxonomyData[groupNum].parameters.find(p => p.id === paramId);
                    
                    // Check if this is Hair Color with variants
                    if (parameter.name === "Hair Color") {
                        // This requires special handling
                        // Find which main color and variant this option represents
                        let optionCount = 0;
                        let foundMainIndex = -1;
                        let foundVariantIndex = -1;
                        
                        for (let i = 0; i < parameter.options.length; i++) {
                            const mainOption = parameter.options[i];
                            if (mainOption.variants) {
                                for (let j = 0; j < mainOption.variants.length; j++) {
                                    if (optionCount === optionIndex) {
                                        foundMainIndex = i;
                                        foundVariantIndex = j;
                                        break;
                                    }
                                    optionCount++;
                                }
                                if (foundMainIndex !== -1) break;
                            } else {
                                if (optionCount === optionIndex) {
                                    foundMainIndex = i;
                                    break;
                                }
                                optionCount++;
                            }
                        }
                        
                        if (foundMainIndex !== -1 && foundVariantIndex !== -1) {
                            window.selectOption(paramId, foundMainIndex, foundVariantIndex);
                        } else {
                            window.selectOption(paramId, foundMainIndex);
                        }
                    } else {
                        // Standard option selection
                        window.selectOption(paramId, optionIndex);
                    }
                    
                    // Also select random modifiers if present
                    const modifiers = Array.from(paramElement.querySelectorAll('.modifier'));
                    modifiers.forEach(mod => {
                        const modName = mod.querySelector('.modifier-name').textContent;
                        const modOptions = Array.from(mod.querySelectorAll('.modifier-option'));
                        if (modOptions.length > 0) {
                            const randomModIndex = Math.floor(Math.random() * modOptions.length);
                            window.selectModifier(paramId, modName, randomModIndex);
                        }
                    });
                    
                    // Wait a bit before completing to simulate human interaction
                    setTimeout(() => {
                        window.completeParameter(paramId);
                        
                        // Continue with random generation if still active
                        if (isRandomGenerating) {
                            randomTimer = setTimeout(makeRandomSelection, randomSpeed);
                        }
                    }, randomSpeed / 2);
                } else {
                    // No options available, try the next visible parameter
                    if (isRandomGenerating) {
                        randomTimer = setTimeout(makeRandomSelection, randomSpeed);
                    }
                }
            } else {
                // No visible parameters, check if we should move to the next group
                const activeGroup = document.querySelector('.group-button.active');
                if (activeGroup) {
                    const groupNum = parseInt(activeGroup.id.replace('group-', ''));
                    const nextGroup = groupNum + 1;
                    
                    if (document.getElementById(`group-${nextGroup}`) && 
                        !document.getElementById(`group-${nextGroup}`).classList.contains('inactive')) {
                        // Open next group
                        toggleGroup(nextGroup);
                        
                        // Continue random generation
                        if (isRandomGenerating) {
                            randomTimer = setTimeout(makeRandomSelection, randomSpeed);
                        }
                    } else {
                        // No more groups, stop random generation
                        isRandomGenerating = false;
                        document.getElementById('random-button').classList.remove('active');
                        document.getElementById('random-button').textContent = 'Auto-Random';
                    }
                }
            }
        }
        
        // Add missing rebuildUIFromSavedData and resetUI functions
        function rebuildUIFromSavedData() {
            // Reset UI first
            resetUI();
            
            // For each completed parameter, rebuild the UI state
            Object.keys(completedParams).forEach(paramId => {
                const groupNum = paramGroups[paramId];
                
                // Make sure group is active
                document.getElementById(`group-${groupNum}`).classList.remove('inactive');
                document.getElementById(`group-${groupNum}`).classList.add('completed');
                
                // Update completed section
                const completedSection = document.getElementById(`completed-${groupNum}`);
                completedSection.classList.remove('hidden');
                
                // Add completed items
                const parameter = taxonomyData[groupNum].parameters.find(p => p.id === parseInt(paramId));
                const completion = completedParams[paramId];
                
                // Get modifier info for display
                let modifierText = '';
                if (modifierSelections[paramId]) {
                    const modifierEntries = Object.entries(modifierSelections[paramId]);
                    if (modifierEntries.length > 0) {
                        modifierText = ' (';
                        modifierEntries.forEach(([modName, modIndex], idx) => {
                            if (parameter.modifiers && parameter.modifiers[modName]) {
                                const modOptions = parameter.modifiers[modName];
                                if (modOptions && modOptions[modIndex]) {
                                    modifierText += `${modOptions[modIndex].name}${idx < modifierEntries.length - 1 ? ', ' : ''}`;
                                }
                            }
                        });
                        modifierText += ')';
                    }
                }
                
                const completedItem = document.createElement('div');
                completedItem.id = `completed-item-${paramId}`;
                completedItem.className = 'completed-item';
                completedItem.innerHTML = `
                    <div><strong>${paramId}. ${parameter.name}:</strong> ${completion.value}${modifierText}</div>
                    <div><button class="edit-button" onclick="editParameter(${paramId})">Edit</button></div>
                `;
                
                completedSection.appendChild(completedItem);
            });
            
            // Update progress bars
            Object.keys(taxonomyData).forEach(groupNum => {
                const groupParams = Object.keys(paramGroups).filter(key => paramGroups[key] === parseInt(groupNum));
                const totalParamsInGroup = groupParams.length;
                const completedParamsInGroup = Object.keys(completedParams)
                    .filter(key => paramGroups[key] === parseInt(groupNum)).length;
                
                const progress = (completedParamsInGroup / totalParamsInGroup) * 100;
                document.getElementById(`progress-${groupNum}`).style.width = `${progress}%`;
            });
            
            // Update character summary and output formats
            updateCharacterSummary();
        }
        
        function resetUI() {
            // Reset group states
            Object.keys(taxonomyData).forEach((groupNum, index) => {
                const groupButton = document.getElementById(`group-${groupNum}`);
                const groupContent = document.getElementById(`content-${groupNum}`);
                
                // Reset groups
                groupButton.classList.remove('completed', 'active');
                groupContent.classList.remove('active');
                groupContent.style.height = '0';
                
                // First group active, others inactive
                if (index === 0) {
                    groupButton.classList.remove('inactive');
                    groupContent.classList.add('active');
                    groupContent.style.height = groupContent.scrollHeight + 'px';
                } else {
                    groupButton.classList.add('inactive');
                }
                
                // Reset progress bars
                document.getElementById(`progress-${groupNum}`).style.width = '0';
                
                // Clear completed sections
                const completedSection = document.getElementById(`completed-${groupNum}`);
                completedSection.innerHTML = '';
                completedSection.classList.add('hidden');
                
                // Reset parameters
                taxonomyData[groupNum].parameters.forEach((param, paramIndex) => {
                    const paramElement = document.getElementById(`parameter-${param.id}`);
                    
                    // Remove selected state from all options
                    paramElement.querySelectorAll('.option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    
                    // Remove selected state from all modifiers
                    paramElement.querySelectorAll('.modifier-option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    
                    // Hide all parameters except the first one in the first group
                    if (index === 0 && paramIndex === 0) {
                        paramElement.classList.remove('hidden');
                    } else {
                        paramElement.classList.add('hidden');
                    }
                });
            });
            
            // Clear character summary
            updateCharacterSummary();
        }
        
        // Add event listeners for speed slider
        document.getElementById('random-speed')?.addEventListener('input', function() {
            randomSpeed = parseInt(this.value);
            document.getElementById('speed-value').textContent = (randomSpeed / 1000).toFixed(1) + 's';
        });
        
        // Add event listeners for tab navigation
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', function() {
                const tabId = this.getAttribute('data-tab');
                
                // Remove active class from all tabs and contents
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                // Add active class to clicked tab and its content
                this.classList.add('active');
                document.getElementById(`${tabId}-tab`).classList.add('active');
            });
        });
        
        // Add keyboard shortcuts
        window.addEventListener('keydown', function(e) {
            // Only process shortcuts if Ctrl key is pressed
            if (e.ctrlKey) {
                switch(e.key.toLowerCase()) {
                    case 's':
                        e.preventDefault();
                        saveCharacter();
                        break;
                    case 'o':
                        e.preventDefault();
                        loadCharacter();
                        break;
                    case 'n':
                        e.preventDefault();
                        newCharacter();
                        break;
                }
            }
        });
        
        // Add copy functionality to copy buttons
        document.querySelector('.copy-content-button')?.addEventListener('click', function() {
            const activeTab = document.querySelector('.tab-content.active');
            let textToCopy = '';
            
            if (activeTab) {
                if (activeTab.id === 'description-tab') {
                    textToCopy = activeTab.textContent;
                } else if (activeTab.id === 't2i-prompt-tab') {
                    textToCopy = activeTab.querySelector('.composed-prompt-text')?.textContent || '';
                } else if (activeTab.id === 'markdown-tab' || activeTab.id === 'json-tab') {
                    textToCopy = activeTab.querySelector('pre')?.textContent || '';
                }
            }
            
            if (textToCopy) {
                navigator.clipboard.writeText(textToCopy)
                    .then(() => showNotification('Copied to clipboard!'))
                    .catch(err => console.error('Error copying text:', err));
            }
        });

        // Make globally available functions for HTML onclick
        window.copyCharacter = copyCharacter;
        window.saveCharacter = saveCharacter;
        window.loadCharacter = loadCharacter;
        window.newCharacter = newCharacter;
        window.toggleGroup = toggleGroup;
        window.toggleRandomGeneration = toggleRandomGeneration;
        
        // Start loading data when page is ready
        document.addEventListener('DOMContentLoaded', loadTaxonomyData);
    </script>
</body>
</html>